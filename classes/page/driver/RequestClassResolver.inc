<?php


namespace page\driver;


/**
 * The RequestClassResolver class determines and instantiates the appropriate class based on the request URI.
 * It extends the base Universe class, providing a dynamic page handling mechanism for the application.
 * By leveraging the RequestClassResolverUriMapper, it decouples the URI resolution logic, enhancing modularity and maintainability.
 */
class RequestClassResolver
{


	/**
	 * The current request URI used to determine the corresponding class to instantiate.
	 * This property is initialized from the $_SERVER global variable, reflecting the current HTTP request.
	 */
	private string $requestUri;
	private \iw\dom\Document $dom;
	private UriClassMapper $uriClassMapper;


	/**
	 * Constructor initializes the class and sets the current request URI.
	 * The constructor ensures that the request URI is captured at the time of object instantiation, providing a snapshot of the request state.
	 */
	public function __construct(\iw\dom\Document $dom, UriClassMapper $uriClassMapper)
	{
		$this->dom= $dom;
		$this->uriClassMapper= $uriClassMapper;
		$this->requestUri = $_SERVER["REQUEST_URI"];
	}


	/**
	 * Retrieves and instantiates the appropriate page class based on the current URI.
	 * This method utilizes the RequestClassResolverUriMapper to determine the class to instantiate and its constructor arguments.
	 *
	 * @return \page\Page An instance of the determined page class, ready for use.
	 * @throws Exception If the determined class does not exist or is of the incorrect type.
	 * @throws \ReflectionException If there is an error during the class reflection process.
	 */
	public function getPageClass(): \page\Page
	{
		$info = $this->getClassInfo();
		$className = $info["className"];
		$matches = $info["matches"];

		return $this->getReflection($className)->newInstanceArgs([$matches, $this->dom]);
	}


	private function getClassInfo(): array
	{
		foreach ($this->uriClassMapper->map() as $pattern => $className) {
			if (preg_match($pattern, $this->requestUri, $matches)) {
				return [
					"className" => $className,
					"matches" => $matches,
				];
			}
		}

		return [
			"className" => $this->uriClassMapper->defaultPageClassName(),
			"matches" => [],
		];
	}


	/**
	 * Creates a reflection of the specified class.
	 * This method checks if the class exists and is a subclass of the expected parent class, providing dynamic type safety.
	 *
	 * @param string $className The name of the class to reflect.
	 *
	 * @return \ReflectionClass A reflection of the class, used for dynamic instantiation.
	 * @throws Exception If the class is not a subclass of the expected parent.
	 * @throws \ReflectionException If the class does not exist.
	 */
	private function getReflection(string $className): \ReflectionClass
	{
		if (!class_exists($className)) {
			Error::RESOLVER_CLASS_NOT_EXISTS->throw("Class '$className' does not exist");
		}
		$reflection = new \ReflectionClass($className);
		if (!$reflection->isSubclassOf(\page\Page::class)) {
			Error::RESOLVER_CLASS_IS_NOT_SUCCESSOR_OF_REQUIRED_PARENT->throw("Class must be successor of the parent '" . \page\Page::class . "'");
		}

		return $reflection;
	}


}
